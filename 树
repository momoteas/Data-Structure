1 树：
    。什么是树：客观世界中许多事物存在层次关系；
    。顺序查找：
        。静态查找：集合中的记录是固定的
        。动态查找：集合中的记录是动态的
    。二分查找：（binary search）
        。假设n个数据元素的关键字满足有序（比如：从小到大）K1 < K2 < ...< Kn，并且是连续存放（树组），那么可以进行二分查找；
        。二分查找判定树：n个结点的判定树的深度为[log以2为底n]+1，代表最坏查找的深度；
    。树的定义：
        。树：n(n>=0)个结点构成的有限集合。当n=0时，称为空树；
        。对于一个棵非空树（n>0）,它具备以下性质：
            。树中有一个称为“根”的特殊结点，用r表示；
            。其余结点可分为m(m>0)互不相交的有限集T1，T2，...，Tm，其中每个集合本身又是一颗树，称为原来树的“子树”（subtree）
    。树与非树：
        。子树是不相交的；
        。除了根结点外，每个结点有且仅有一个父结点；
        。一个N个结点的树由N-1条边；
    。树的一些基本术语：
        。结点的度（Degree）:结点的子树个树；
        。树的度：树的所有结点中最大的度数；
        。叶结点（Leaf):度为0的结点；
        。父结点（Parent）:有子树的结点是其子树的根结点的父结点；
        。子结点（Child）:若A结点是B结点的父结点，则称B结点是A结点的子结点；子结点也称孩子结点；
        。兄弟结点（Sibling）:具有同一父结点的各结点彼此是兄弟结点；
        。路径和路径的长度：从结点n1到nk的路径为一个结点序列n1,n2,...,nk,ni是ni+1的父结点。路径所包含边的个树为路径的长度；
        。祖先结点（Ancestor）:沿树根到某一结点路径上的所有结点都是这个结点的祖先结点；
        。子孙结点（Descentdant）:某一结点的子树中的所有结点是这个结点的子孙；
        。结点的层次（Level）:规定根结点在1层，其它任一结点的层数是其父结点的层数加1；
        。树的深度（Depth）:树中所有结点中最大层次是这棵树的深度；
2 树的表示：
    。儿子-兄弟表示法：
    。二叉树
3 二叉树：
    。定义：二叉树T，一个有穷的结点集合。
         ：这个集合可以为空；
         ：若不为空，则它是由根结点和称为其左子树和右子树的两个不相交的二叉树组成；
    。特殊二叉树：
        。斜二叉树
        。完美二叉树
        。完全二叉树
    。二叉树几个重要性质：
        。一个二叉树第i层的最大结点数为：2的（k-1）次方，i>=1;
        。深度为k的二叉树有最大结点总数为：2的k次方-1，k>=1;
        .对任何非空二叉树T，若n零表示叶结点的个数，n二是度为2的非叶结点个数，那么两者满足关系n零=n二+1；
    。二叉树的抽象数据类型定义：
        。数据对象集：一个有穷的结点集合；若不为空，则由根结点和其左、右二叉子树组成；
        。操作集：
            。Boolen IsEmpty(BinTree BT):判断BT是否为空；
            。void Traversal(BinTree BT)：遍历，按某顺序访问每个结点；
            。BinTree CreatBinTree():创建一个二叉树；
        。常见的遍历方法：
            。void PreOrdertraversal(BinTree BT):先序---根、左子树、右子树；
            。void InOrderTraversal(BinTree BT)：中序---左子树、根、右子树；
            。void PostOrderTraversal(BinTree BT):后序---左子树、右子树、根；
            。void LeverOrderTraversal(BinTree BT):层次遍历，从上到下，从左到右；
    。二叉树的存储结构：
        。顺序存储结构：
            。数组存储方式
                。完全二叉树：按从上到下，从左到右顺序存储n个结点的完全二叉树的结点父子关系：
                    。非根结点的父结点的序号是（i/2）;
                    。结点的左孩子结点的序号是2i;(若2i<=n, 否则没有左孩子)
                    。结点的右孩子结点的序号是2i+1;(若2i+1<=n, 否则没有右孩子)；
                。一般二叉树：也可以采用这种结构（不全不存在的空位），但是会造成空间浪费...        
            。链表存储：
                。定义结构：      typedef struct TreeNode *BinTree;
                                typedef BinTree Position;   
                                 sruct TreeNode{
                                        ElementType Data;
                                        BinTree Left;
                                        BinTree Right;
                                 };
        。二叉树的遍历：以链式存储为例
            。先序遍历过程：用递归程序实现
                。访问根结点；
                。先序遍历其左子树；
                。先序遍历其右子树；
            。中序遍历：递归实现
                。中序遍历其左子树；
                。访问根结点；
                。中序遍历其右子树；
                。代码：        void InOrderTraversal(BinTree BY)
                               {
                                    if(BT){
                                        InOrderTraversal(BT->Left);
                                        printf("%d", BT->Data);
                                        InOrderTraversal(BT->Right);
                                    }
                                }
           。后序遍历：...
           。先序，中序和后序遍历过程：遍历过程中经过结点的路线一样，只是访问各结点的时机不同；
       。二叉树的非递归遍历：
           。中序遍历非递归遍历算法：基本思路是使用堆栈
                。遇到一个结点，就把它压栈，并去遍历它的左子树；
                。当左子树遍历结束后，从栈顶弹出这个结点并访问它；
                。然后按其右指针再去中序遍历该结点的右子树；
           。先序遍历的非递归遍历算法：...     
       。层序遍历：
           。二叉树遍历的核心问题：二维结构的线性化
                。需要一个存储结构保存暂时不访问的结点；
                。存储结构：堆栈，队列；
           。队列实现：遍历从根结点开始，首先将根结点入队，然后开始执行循环：结点出队、访问该结点、其左右儿子入队；
                。层序基本过程：县根结点入队，然后：
                    。从队列中取出一个元素；
                    。访问该元素所指结点；
                    。若该元素所指结点的左、右孩子结点非空，则将其左、右孩子的指针顺序入队；
           
                
           
           
           
                                    
            
        
        






