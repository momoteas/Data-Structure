1 树：
    。什么是树：客观世界中许多事物存在层次关系；
    。顺序查找：
        。静态查找：集合中的记录是固定的
        。动态查找：集合中的记录是动态的
    。二分查找：（binary search）
        。假设n个数据元素的关键字满足有序（比如：从小到大）K1 < K2 < ...< Kn，并且是连续存放（树组），那么可以进行二分查找；
        。二分查找判定树：n个结点的判定树的深度为[log以2为底n]+1，代表最坏查找的深度；
    。树的定义：
        。树：n(n>=0)个结点构成的有限集合。当n=0时，称为空树；
        。对于一个棵非空树（n>0）,它具备以下性质：
            。树中有一个称为“根”的特殊结点，用r表示；
            。其余结点可分为m(m>0)互不相交的有限集T1，T2，...，Tm，其中每个集合本身又是一颗树，称为原来树的“子树”（subtree）
    。树与非树：
        。子树是不相交的；
        。除了根结点外，每个结点有且仅有一个父结点；
        。一个N个结点的树由N-1条边；
    。树的一些基本术语：
        。结点的度（Degree）:结点的子树个树；
        。树的度：树的所有结点中最大的度数；
        。叶结点（Leaf):度为0的结点；
        。父结点（Parent）:有子树的结点是其子树的根结点的父结点；
        。子结点（Child）:若A结点是B结点的父结点，则称B结点是A结点的子结点；子结点也称孩子结点；
        。兄弟结点（Sibling）:具有同一父结点的各结点彼此是兄弟结点；
        。路径和路径的长度：从结点n1到nk的路径为一个结点序列n1,n2,...,nk,ni是ni+1的父结点。路径所包含边的个树为路径的长度；
        。祖先结点（Ancestor）:沿树根到某一结点路径上的所有结点都是这个结点的祖先结点；
        。子孙结点（Descentdant）:某一结点的子树中的所有结点是这个结点的子孙；
        。结点的层次（Level）:规定根结点在1层，其它任一结点的层数是其父结点的层数加1；
        。树的深度（Depth）:树中所有结点中最大层次是这棵树的深度；
2 树的表示：
    。儿子-兄弟表示法：
    。二叉树
3 二叉树：
    。定义：二叉树T，一个有穷的结点集合。
         ：这个集合可以为空；
         ：若不为空，则它是由根结点和称为其左子树和右子树的两个不相交的二叉树组成；
    。特殊二叉树：
        。斜二叉树
        。完美二叉树
        。完全二叉树
    。二叉树几个重要性质：
        。一个二叉树第i层的最大结点数为：2的（k-1）次方，i>=1;
        。深度为k的二叉树有最大结点总数为：2的k次方-1，k>=1;
        .对任何非空二叉树T，若n零表示叶结点的个数，n二是度为2的非叶结点个数，那么两者满足关系n零=n二+1；
    。二叉树的抽象数据类型定义：
        。数据对象集：一个有穷的结点集合；若不为空，则由根结点和其左、右二叉子树组成；
        。操作集：
            。Boolen IsEmpty(BinTree BT):判断BT是否为空；
            。void Traversal(BinTree BT)：遍历，按某顺序访问每个结点；
            。BinTree CreatBinTree():创建一个二叉树；
        。常见的遍历方法：
            。void PreOrdertraversal(BinTree BT):先序---根、左子树、右子树；
            。void InOrderTraversal(BinTree BT)：中序---左子树、根、右子树；
            。void PostOrderTraversal(BinTree BT):后序---左子树、右子树、根；
            。void LeverOrderTraversal(BinTree BT):层次遍历，从上到下，从左到右；
        
        
        






