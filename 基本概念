1 基本概念：
    。算法效率：
        。最坏情况复杂度 T[wors]](n);
        。平均复杂度 T[avg](n);
        。一般情况下，平均复杂度 < 最坏复杂度；
        。复杂度分析小窍门：
            。若两段算法分别有复杂度T[1](n)=O(f[1](n))和T[2](n)=O(f[2](n)),则：
                。T[1](n) + T[2](n) = max(O(f[1](n), O(f[2](n)));
                。T[1](n) * T[2](n) = O(f[1](n) * f[2](n))
            。若T(n)时关于n的k阶多项式，那么T(n)=O(n的次方)
            。一个for循环的时间复杂度等于循环次数乘以循环体代码的复杂度；
            。if-else结构的复杂度取决于if的条件判断复杂度和两个分支部分的复杂度，总体复杂度取三者中最大；
        。分而治之思想：
      
2 线性结构：
    。2.1 线性表及其实现：
        。顺序存储结构直接表示：数组各分量对应多项式各项。a[i]:项x^i的系数a下标i;
            。缺点：容易造成空间的浪费；
        。顺序存储结构表示非零项：
            。用结构数组表示：数组分量是由系数a^i,指数i组成的结构，对应一个非零项；
            。按指数大小有序存储；
            。相加过程：从头开始，比较两个多项式当前对应项的指数；
        。链表结构存储非零项：
            。链表中每个节点存储多项式中的一个非零项，包括系数和指数两个数据域以及一个指针域；
            。结构定义：      typedef struct PolyNode *Polynomial;
                            struct PolyNode{
                                int coef;
                                int expon;
                                Polynomial link;
                            };
        。什么时线性表：
            。Linear List:由同类型数据元素构成有序序列的线性结构；
                。表中元素个数称为线性表的长度；
                。线性表没有元素时，成为空表；
                。表起始位置称为表头，表结束位置称表尾；
        。线性表的抽象数据类型描述：
            。类型名称：线性表 List;
            。数据对象集：线性表是n(>=0)个元素构成的有序序列（a1,a2,a3...,an）;
            。操作集：线性表L属于List,整数i表示位置，元素X属于ElementType,线性表基本操作主要有：
                。List MakEmpty():初始化一个空线性表L；
                。ElementType FindKth(int K, List L):根据位序K，返回相应元素；
                。int Find(ElementType X, List L):在线性表L中查找X的第一次出现位置；
                。void Insert(ElementType X, int i, List L):在位序i前插入一个新元素x；
                。void Delete(int i, List L):删除指定位序i的元素；
                。int Length(List L):返回线性表L的长度n；
        。线性表的顺序存储实现：
            。利用数组的连续存储空间顺序存放线性表的各元素；
        。线性表的链式存储实现：
            。不要求逻辑上相邻的两个元素物理上也相邻：通过“链”建立起数据元素之间的逻辑关系；
            。插入，删除不需要移动数据元素，只需要修改“链”
        。广义表：
            。广义表是线性表的推广；
            。对于线性表而言，n个元算都是基本的单元素；
            。广义表，这些元素不仅可以是单元素也可以是另一个广义表；
            。构造：
                           typedef struct Gnode *GList;
                           struct Gnode{
                                int tag;    /*标志域：0表示节点是单元素，1表示节点是广义表 */
                                union{
                                    ElementType Data;
                                    GList SubList;
                                }URegion;
                                GList Next;     /*指向后继节点*/
                           };
        。多重链表：
            。多重链表：链表中的节点可能同时隶属于多个链；
                。多重链表中节点的指针域会有多个，如前面例子包含了Next和Sublist两个指针域；
                。但是包含两个指针域的链表并一定是多重链表，比如在双向链表不是多重链表；
            。多重链表有广泛的用途：
                。基本如树，图这样相对复杂的数据结构都可以采用多重链表方式实现存储；
            。稀疏矩阵用十字链表来解决存储：
                。用一个标识域Tag来区分头结点和非0元素结点；
                。头节点的标识值为“Head”，矩阵非0元素结点的标识值为“Term“；
                                        Tag 
                                 Down  URegion  Right
                                    结点的总体结构
                        Term                                  Head
                      Row  Col                        Down    Next    Right
                  Down   Value    Right                      头结点
                      矩阵非0元素结点         
            
      
      
      
      
      
      
